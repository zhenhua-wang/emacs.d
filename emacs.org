#+Title: Emacs Configuration
#+AUTHOR: Zhenhua Wang
#+auto_tangle: t
#+PROPERTY: header-args+ :tangle "yes"

This is my personal configuration for emacs. I am using ~(org-babel-load-file)~ to directly load it into init.el. Since this function will only tangle the file only if the current file is new, I am using ~if-else/when/pcase~ to detect OS. 
--------------
* Header
#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* Startup
** Package management
*** Add custom file and path
#+begin_src emacs-lisp
;; Load path for manually installed packages
(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))

;; Load path for customied themes
(add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))
#+end_src

*** straight
#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

*** use-package
#+begin_src emacs-lisp
;; Install use-package
(straight-use-package 'use-package)
;; Configure use-package to use straight.el by default
(setq straight-use-package-by-default t)
;; disable checking at start-up
(setq straight-check-for-modifications '(watch-files find-when-checking))
(setq use-package-always-ensure t)
(setq use-package-verbose t)
#+end_src

** Garbage collection
#+begin_src emacs-lisp
(use-package gcmh
  :diminish
  :hook
  (after-init . gcmh-mode)
  :init
  (setq gcmh-idle-delay 'auto
        gcmh-auto-idle-delay-factor 10
        gcmh-high-cons-threshold #x1000000))
#+end_src

** Keep .emacs.d Clean
#+begin_src emacs-lisp
;; Change the user-emacs-directory to keep unwanted things out of ~/.emacs.d
(setq user-emacs-directory (expand-file-name "~/.cache/emacs/")
      url-history-file (expand-file-name "url/history" user-emacs-directory))

;; Use no-littering to automatically set common paths to the new user-emacs-directory
(use-package no-littering)

;; Keep customization settings in a temporary file (thanks Ambrevar!)
(setq custom-file
      (if (boundp 'server-socket-dir)
          (expand-file-name "custom.el" server-socket-dir)
          (expand-file-name (format "emacs-custom-%s.el" (user-uid)) temporary-file-directory)))
(load custom-file t)
#+end_src

** Benchmark
#+begin_src emacs-lisp
(use-package benchmark-init
  :init
  (benchmark-init/activate)
  :config
  ;; To disable collection of benchmark data after init is done.
  (add-hook 'after-init-hook 'benchmark-init/deactivate))
#+end_src

* General Setting
** Global variable
#+begin_src emacs-lisp
(setq zw/font-size 170)
(setq zw/font-size-fixed-pitch 140)
(setq zw/font-size-variable-pitch 200)
(setq zw/font-size-dashboard 200)
(setq zw/default-font "Ubuntu Mono")
(setq zw/font-fixed-pitch "Hack") ;; "JetBrains Mono"
(setq zw/font-variable-pitch "ETBembo Italic")
(setq zw/font-title "ETBembo")
(setq zw/font-dashboard "Ubuntu")
#+end_src

** Common setting
  #+begin_src emacs-lisp
(use-package emacs
  :straight (:type built-in)
  :hook
  (after-init . global-visual-line-mode)
  ;; Revert buffers when the underlying file has changed
  (after-init . global-auto-revert-mode)
  ;; yank overwrite what is selected
  (after-init . delete-selection-mode)
  ;; fringe (nil is default)
  (after-init . fringe-mode)
  :config
  ;; default coding
  (set-default-coding-systems 'utf-8)
  ;; start server mode
  (server-start)
  ;; cursor
  (setq-default cursor-type 'bar)
  ;; save clipboard before kill ring
  (setq save-interprogram-paste-before-kill t)
  (setq-default select-enable-clipboard t)
  ;; completion
  (setq completion-cycle-threshold nil)
  (setq tab-always-indent t)
  (setq completions-detailed t)
  (setq completion-ignore-case t)
  ;; Revert Dired and other buffers
  (setq global-auto-revert-non-file-buffers t)
  ;; Use spaces instead of tabs for indentation
  (setq indent-tabs-mode nil)
  ;; confirm emacs quit
  (setq confirm-kill-emacs 'yes-or-no-p)
  ;; simplify yes no
  ;; (defalias 'yes-or-no-p 'y-or-n-p)
  ;; make scratch and dashboard unkillable
  (add-hook 'kill-buffer-query-functions #'zw/dont-kill-scratch)
  (defun zw/dont-kill-scratch ()
    (if (not (or (equal (buffer-name) "*scratch*")
		 (equal (buffer-name) "*dashboard*")))
	t
      ;; (message "Not allowed to kill %s, burying instead" (buffer-name))
      (bury-buffer)
      nil)))
  #+end_src

** Keybinding
#+begin_src emacs-lisp
;; ------------------- key bind ---------------------
;; general keybindings
;; (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(global-set-key (kbd "<escape>") (kbd "C-g"))
(global-set-key (kbd "<C-tab>") 'completion-at-point)
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x C-b"))
(global-unset-key (kbd "C-<mouse-4>"))          ; disable scroll zoom
(global-unset-key (kbd "C-<mouse-5>"))          ; disable scroll zoom
(global-unset-key (kbd "C-<wheel-down>"))       ; disable scroll zoom
(global-unset-key (kbd "C-<wheel-up>"))         ; disable scroll zoom
;; editing
(global-set-key (kbd "s-z") 'undo)
(global-set-key (kbd "s-x") 'kill-region)
(global-set-key (kbd "s-c") 'kill-ring-save)
(global-set-key (kbd "s-v") 'yank)
(global-set-key (kbd "s-a") 'mark-whole-buffer)
(global-set-key (kbd "s-s") 'save-buffer)
(global-set-key (kbd "s-l") 'goto-line)
(define-key isearch-mode-map (kbd "s-f") 'isearch-repeat-forward)
;; vterm
(global-set-key (kbd "s-e") 'vterm)
;; buffer operations
(global-set-key (kbd "s-q") 'kill-current-buffer)
;; window operations
(global-set-key (kbd "s-w") 'delete-window)
(global-set-key (kbd "s-t") 'split-window-sensibly-prefer-horizontal)
(global-set-key [s-left] 'windmove-left)          ; move to left window
(global-set-key [s-right] 'windmove-right)        ; move to right window
(global-set-key [s-up] 'windmove-up)              ; move to upper window
(global-set-key [s-down] 'windmove-down)          ; move to lower window
;; tab operations
(global-set-key (kbd "s-1") (lambda () (interactive) (tab-select 1)))
(global-set-key (kbd "s-2") (lambda () (interactive) (tab-select 2)))
(global-set-key (kbd "s-3") (lambda () (interactive) (tab-select 3)))
(global-set-key (kbd "s-4") (lambda () (interactive) (tab-select 4)))
(global-set-key (kbd "s-5") (lambda () (interactive) (tab-select 5)))
(global-set-key (kbd "s-n") 'tab-new)
;; toggle transparency
(global-set-key (kbd "s-T") 'zw/toggle-transparency)
;; get passwed
;; (global-set-key (kbd "C-c p") 'zw/get-passwd)
;; toggle input
(global-set-key (kbd "s-\\") 'toggle-input-method)
;; macos keys
(pcase system-type
  ('darwin
   (progn
     (setq mac-right-command-modifier 'hyper)
     (setq mac-command-modifier 'super)
     (setq mac-option-modifier 'meta))))
#+end_src

* Integration
** Exec-path-from-shell
#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :if (or (eq system-type 'darwin)
	  (eq system-type 'gnu/linux)
	  (daemonp))
  :init
  (setq exec-path-from-shell-check-startup-files nil)
  (exec-path-from-shell-initialize))
#+end_src

** TRAMP
For host with two factor auth, you need to
1. enter password
2. enter the second-step code

#+begin_src emacs-lisp
;; Set default connection mode to SSH
(setq tramp-default-method "ssh")
#+end_src

** Vterm
For detailed Config, see https://github.com/akermu/emacs-libvterm#shell-side-configuration

#+begin_src emacs-lisp
(use-package vterm
  :if (not (eq system-type 'windows-nt))
  :straight `(:pre-build (("rm" "-fr" "build")
			  ("mkdir" "build")
			  ("bash" "-c" "cd \"$1\" && cmake .. && make" "--"
			   ,(concat (straight--repos-dir "emacs-libvterm") "build"))))
  :bind
  ((:map vterm-copy-mode-map
         ("<return>" . vterm-copy-mode))
   (:map vterm-mode-map
         ("s-e" . delete-window)))
  :init
  (setq vterm-kill-buffer-on-exit t)
  ;; close window when vterm exit
  (add-hook 'vterm-exit-functions
	    (lambda (_ _)
	      (let* ((buffer (current-buffer))
		     (window (get-buffer-window buffer)))
		(when (not (one-window-p))
		  (delete-window window)))))
  :config
  (zw/set-vterm-color))
#+end_src

** Dired
#+begin_src emacs-lisp
(use-package dired-single
  :config
  (define-key dired-mode-map [remap dired-find-file]
	      'dired-single-buffer)
  (define-key dired-mode-map [remap dired-mouse-find-file-other-window]
	      'dired-single-buffer-mouse)
  (define-key dired-mode-map [remap dired-up-directory]
	      'dired-single-up-directory))

(use-package all-the-icons-dired
  :if (display-graphic-p)
  :hook (dired-mode . all-the-icons-dired-mode)
  :init (setq all-the-icons-dired-monochrome nil))
#+end_src

** Openwith
#+begin_src emacs-lisp
(use-package openwith
  :hook
  (after-init . openwith-mode)
  :config
  (setq openwith-associations
        (list
	 (list (openwith-make-extension-regexp
                '("doc" "docx" "xls" "xlsx" "ppt" "pptx" "odt" "ods" "odg" "odp"
		  "mpg" "mpeg" "mp3" "mp4" "avi" "wmv" "wav" "mov" "flv" "ogm" "ogg" "mkv"))
               "open"
               '(file)))))
#+end_src

** Request
#+begin_src emacs-lisp
(use-package request
  :defer 1)
#+end_src

** Recentf
#+begin_src emacs-lisp
(use-package recentf
  :straight (:type built-in)
  :hook (after-init . recentf-mode)
  :init (setq recentf-max-saved-items 300
              recentf-exclude
              '("\\.?cache" ".cask" "url" "COMMIT_EDITMSG\\'" "bookmarks"
                "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\|bmp\\|xpm\\)$"
                "\\.?ido\\.last$" "\\.revive$" "/G?TAGS$" "/.elfeed/"
                "^/tmp/" "^/var/folders/.+$" "^/ssh:" "/persp-confs/" "~/.emacs.d/straight/"
		no-littering-var-directory no-littering-etc-directory
                (lambda (file) (file-in-directory-p file package-user-dir))))
  :config
  (push (expand-file-name recentf-save-file) recentf-exclude)
  (add-to-list 'recentf-filename-handlers #'abbreviate-file-name))
#+end_src

** Savehist
#+begin_src emacs-lisp
;; Persist history over Emacs restarts. Vertico sorts by history position.
(use-package savehist
  :hook (after-init . savehist-mode)
  :config (setq enable-recursive-minibuffers t ; Allow commands in minibuffers
		history-length 1000))
#+end_src

* Interface
** Font face
Vanilla Emacs: You can use ~C-x C-+~ and ~C-x C--~ (~text-scale-adjust~) to increase or decrease the buffer text size (~C-+~ or ~C--~ to repeat).

#+begin_src emacs-lisp
(set-face-attribute 'default nil
                       :font zw/default-font
                       ;; make fonts less tranparent
                       ;; :weight 'medium
                       :height zw/font-size)

;; Set the fixed pitch face
(set-face-attribute 'fixed-pitch nil
                    :font zw/font-fixed-pitch
                    :weight 'normal
                    :height zw/font-size-fixed-pitch)

;; Set the variable pitch face
(set-face-attribute 'variable-pitch nil
                    :font zw/font-variable-pitch
                    :weight 'light
                    :height zw/font-size-variable-pitch)

;; Use variable width font faces in current buffer
(defun zw/buffer-face-mode-variable ()
  "Set font to a variable width (proportional) fonts in current buffer"
  (interactive)
  (setq buffer-face-mode-face
	(list ':family zw/font-variable-pitch ':height zw/font-size-variable-pitch))
  (buffer-face-mode))

;; Use monospaced font faces in current buffer
(defun zw/buffer-face-mode-fixed ()
  "Sets a fixed width (monospace) font in current buffer"
  (interactive)
  (setq buffer-face-mode-face
	(list ':family zw/font-fixed-pitch ':height zw/font-size-fixed-pitch))
  (buffer-face-mode))

;; Set default font faces for Info and ERC modes
(add-hook 'text-mode-hook 'zw/buffer-face-mode-variable)
(add-hook 'prog-mode-hook 'zw/buffer-face-mode-fixed)
(add-hook 'markdown-mode-hook 'zw/buffer-face-mode-fixed)
(add-hook 'latex-mode-hook 'zw/buffer-face-mode-fixed)
(add-hook 'LaTeX-mode-hook 'zw/buffer-face-mode-fixed)
#+end_src

** Theme
#+begin_src emacs-lisp
(use-package modus-themes
  :init
  ;; Configure the Modus Themes' appearance
  (setq modus-themes-mode-line '(moody accented borderless (height . 0.9))
	modus-themes-bold-constructs t
	modus-themes-italic-constructs t
	modus-themes-fringes 'subtle
	modus-themes-tabs-accented t
	modus-themes-paren-match '(bold intense)
	modus-themes-prompts '(bold intense)
	modus-themes-region '(accented)
	modus-themes-completions '((matches . (extrabold))
                                   (selection . (semibold accented))
                                   (popup . (accented intense)))
	modus-themes-org-blocks 'gray-background
	modus-themes-scale-headings t
	modus-themes-headings '((1 . (rainbow overline background 1.4))
				(2 . (rainbow background 1.3))
				(3 . (rainbow bold 1.2))
				(t . (semilight 1.1))))
  ;; Load the theme files before enabling a theme
  (modus-themes-load-themes)
  :config
  ;; Load the theme of your choice:
  (modus-themes-load-operandi)
  :bind ("<f5>" . zw/modus-themes-toggle))

(require 'zw-org-theme)
(require 'zw-md-theme)
(require 'zw-vterm-theme)

(defun zw/update-theme ()
  (interactive)
  (zw/modeline-theme)
  (zw/tab-bar-theme)
  (zw/set-org-headline)
  (zw/set-md-headline)
  (zw/set-vterm-color))

(defun zw/modus-themes-toggle ()
  (interactive)
  (modus-themes-toggle)
  (zw/update-theme))
#+end_src

** Tab bar
#+begin_src emacs-lisp
(setq tab-bar-tab-name-function 'tab-bar-tab-name-truncated)
(setq tab-bar-new-tab-choice "*scratch*")
(setq tab-bar-new-button-show nil)
(setq tab-bar-close-button-show nil)
;; this should be placed after theme, since theme would overwrite these attributes
(defun zw/tab-bar-theme ()
  (interactive)
  (set-face-attribute 'tab-bar-tab nil
                      ;; :background (face-background 'mode-line)
		      :foreground (face-foreground 'default)
                      :background (face-background 'mode-line)
                      :underline "#950b96"
		      :box (face-background 'mode-line)
                      :font zw/default-font)
  (set-face-attribute 'tab-bar-tab-inactive nil
		      :foreground (face-foreground 'default)
                      :background (face-background 'mode-line)
                      :underline nil
		      :box (face-background 'mode-line)
                      :font zw/default-font)
  (set-face-attribute 'tab-bar nil
		      :background (face-background 'mode-line)))
;; set tab-bar theme
(zw/tab-bar-theme)
;; display battery to the right
(setq tab-bar-format '(tab-bar-format-menu-bar
		       tab-bar-format-history
		       tab-bar-format-tabs
		       tab-bar-separator
		       tab-bar-format-align-right
		       tab-bar-format-global))
;; show battery
(require 'battery)
(setq have-battery-status-p
      (let ((perc-charged (assoc ?p (funcall battery-status-function))))
    (and perc-charged
         (not (zerop (string-to-number (cdr perc-charged)))))))
(if have-battery-status-p
    (display-battery-mode 1))
;; show menu
(defun tab-bar-format-menu-bar ()
  "Produce the Menu button for the tab bar that shows the menu bar."
  `((menu-bar menu-item (propertize " λ" 'face 'tab-bar)
              tab-bar-menu-bar :help "Menu Bar")))

(tab-bar-mode 1)
#+end_src

** Modeline
#+begin_src emacs-lisp
(defun zw/modeline-theme ()
  (interactive)
  (setq x-underline-at-descent-line t)
  (setq x-use-underline-position-properties nil)
  (set-face-attribute 'mode-line          nil :box nil :height 0.9)
  (set-face-attribute 'mode-line-active   nil :box nil :height 0.9)
  (set-face-attribute 'mode-line-inactive nil :box nil :height 0.9))

(use-package minions
  :hook (doom-modeline . minions-mode))

(use-package doom-modeline
  :hook
  (after-init . doom-modeline-mode)
  :custom
  (doom-modeline-bar-width 8)
  (doom-modeline-lsp t)
  (doom-modeline-enable-word-count t)
  (doom-modeline-icon t)
  (doom-modeline-major-mode-icon t)
  (doom-modeline-minor-modes nil)
  (doom-modeline-buffer-state-icon t)
  (doom-modeline-checker-simple-format nil)
  (doom-modeline-buffer-file-name-style 'truncate-except-project)
  :config
  (zw/modeline-theme)
  ;; show that the R is running in inferior ess R mode
  (add-hook 'inferior-ess-mode-hook
	    (lambda ()
              (add-to-list 'mode-line-process '(:eval (nth ess--busy-count ess-busy-strings)))))
  ;; hide battery on modeline and show it on tab-bar
  (remove-hook 'display-battery-mode-hook #'doom-modeline-override-battery-modeline)
  (remove-hook 'doom-modeline-mode-hook #'doom-modeline-override-battery-modeline))
#+end_src

** Dashboard
#+begin_src emacs-lisp
(use-package dashboard
  :disabled
  :bind
  (:map dashboard-mode-map ("<tab>" . dashboard-return))
  :init
  (dashboard-setup-startup-hook)
  (setq dashboard-startup-banner 1
	dashboard-center-content t
	dashboard-items '((recents  . 10))
	dashboard-projects-switch-function 'counsel-projectile-switch-project-by-name
	dashboard-set-footer nil
	dashboard-set-init-info nil
	dashboard-set-heading-icons nil
	dashboard-set-file-icons nil)
  :config
  (set-face-attribute 'dashboard-items-face nil
                      :font zw/font-dashboard
                      :height zw/font-size-dashboard)
  (set-face-attribute 'dashboard-heading nil
                      :font zw/font-dashboard
                      :height zw/font-size-dashboard))
#+end_src

** iMenu
#+begin_src emacs-lisp
(use-package imenu-list
  ;; don't lazy load this, otherwise its face won't break
  :demand
  :bind
  ("C-c =" . imenu-list-smart-toggle)
  :init
  (setq imenu-list-focus-after-activation t)
  :config
  ;; set window placement
  ;; set modeline
  (defun zw/imenu-list--set-mode-line ()
    (setq zw/imenu-list-mode-line-format
	  '("%e" (:eval (doom-modeline-segment--bar))
	    " TOC: " (:eval (buffer-name imenu-list--displayed-buffer))))
    (setq-local mode-line-format zw/imenu-list-mode-line-format))
  (advice-add #'imenu-list--set-mode-line :override #'zw/imenu-list--set-mode-line)
  ;; fix eglot
  (defun imenu-list--current-entry-via-excursion ()
    (let ((point-pos (point-marker))
          (offset (point-min-marker))
          match-entry)
      (dolist (entry imenu-list--line-entries match-entry)
	(unless (imenu--subalist-p entry)
          (let ((entry-pos (save-mark-and-excursion
                             (imenu entry)
                             (point))))          
            (when (imenu-list-<= offset entry-pos point-pos)
              (setq offset entry-pos)
              (setq match-entry entry)))))))
  (advice-add #'imenu-list--current-entry :override #'imenu-list--current-entry-via-excursion))
#+end_src

** Helpful
#+begin_src emacs-lisp
(use-package helpful
  :bind
  ("C-h f" . helpful-callable)
  ("C-h v" . helpful-variable)
  ("C-h k" . helpful-key))
#+end_src

** Scroll
#+begin_src emacs-lisp
;; Mouse & Smooth Scroll
;; Scroll one line at a time (less "jumpy" than defaults)
(when (display-graphic-p)
  (setq mouse-wheel-scroll-amount '(1 ((shift) . hscroll))
        mouse-wheel-scroll-amount-horizontal 1
        mouse-wheel-progressive-speed nil))
(setq scroll-step 1
      scroll-margin 0
      scroll-conservatively 100000
      auto-window-vscroll nil
      scroll-preserve-screen-position t)

;; Good pixel line scrolling
(if (fboundp 'pixel-scroll-precision-mode)
    (pixel-scroll-precision-mode t))

(use-package iscroll
  :diminish
  :hook
  (image-mode . iscroll-mode)
  (org-mode . iscroll-mode)
  (markdown-mode . iscroll-mode))
#+end_src

** Posframe
#+begin_src emacs-lisp
(use-package posframe
  :init
  (defface posframe-border
    `((t (:background ,(face-foreground 'shadow nil t))))
    "Face used by the `posframe' border."
    :group 'posframe)

  (defun my-set-posframe-faces ()
    "Set `posframe' faces."
    (custom-set-faces
     `(posframe-border ((t (:background ,(face-foreground 'shadow nil t)))))))

  (with-eval-after-load 'persp-mode
    (add-hook 'persp-load-buffer-functions
              (lambda (&rest _)
                (posframe-delete-all))))
  :config
  (with-no-warnings
    (defun my-posframe--prettify-frame (&rest _)
      (set-face-background 'fringe nil posframe--frame))
    (advice-add #'posframe--create-posframe :after #'my-posframe--prettify-frame)

    (defun posframe-poshandler-frame-center-near-bottom (info)
      (cons (/ (- (plist-get info :parent-frame-width)
                  (plist-get info :posframe-width))
               2)
            (/ (+ (plist-get info :parent-frame-height)
                  (* 2 (plist-get info :font-height)))
               2)))))
#+end_src

** Keybinding Hints
*** Hydra
   #+begin_src emacs-lisp
(use-package hydra
  :hook (emacs-lisp-mode . hydra-add-imenu))
   #+end_src

*** Which key
   #+begin_src emacs-lisp
(use-package which-key
  :diminish
  :hook (after-init . which-key-mode)
  :config
  (setq which-key-idle-delay 0.3))
   #+end_src

** Visualize
*** All-the-icons
   #+begin_src emacs-lisp
(use-package all-the-icons
  :if (display-graphic-p)
  :init (setq all-the-icons-scale-factor 1))
   #+end_src

*** Line number mode
   #+begin_src emacs-lisp
;; line number mode
(setq column-number-mode t)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
(add-hook 'text-mode-hook 'display-line-numbers-mode)
(add-hook 'conf-mode-hook 'display-line-numbers-mode)
;; Override some modes which derive from the above
(dolist (mode '(org-mode-hook markdown-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))
   #+end_src

*** Rain-bow-delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+end_src

*** Rainbow mode

   #+begin_src emacs-lisp
;; Sets the background of HTML color strings in buffers to be the color mentioned.
(use-package rainbow-mode
  :hook
  (prog-mode . rainbow-mode)
  (text-mode . rainbow-mode))
   #+end_src

*** Pulsar
#+begin_src emacs-lisp
(use-package pulsar
  :init
  (setq pulsar-pulse-functions
	'(recenter-top-bottom
	  move-to-window-line-top-bottom
	  reposition-window
	  forward-page
	  backward-page
	  scroll-up-command
	  scroll-down-command
	  org-next-visible-heading
	  org-previous-visible-heading
	  org-forward-heading-same-level
	  org-backward-heading-same-level
	  outline-backward-same-level
	  outline-forward-same-level
	  outline-next-visible-heading
	  outline-previous-visible-heading
	  outline-up-heading))
  (setq pulsar-pulse-on-window-change t)
  (setq pulsar-pulse t)
  (setq pulsar-delay 0.055)
  (setq pulsar-iterations 10)
  (setq pulsar-face 'pulsar-generic)
  (setq pulsar-highlight-face 'pulsar-yellow)
  :hook
  (after-init . pulsar-global-mode))
#+end_src

*** Toggle transparency
#+begin_src emacs-lisp
(defun zw/toggle-transparency ()
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (set-frame-parameter
     nil 'alpha
     (if (eql (cond ((numberp alpha) alpha)
                    ((numberp (cdr alpha)) (cdr alpha))
                    ;; Also handle undocumented (<active> <inactive>) form.
                    ((numberp (cadr alpha)) (cadr alpha)))
              100)
         '(85 . 85) '(100 . 100)))))
#+end_src

*** Highlight line
#+begin_src emacs-lisp
;; Highlight the current line
(use-package hl-line
  :straight (:type built-in)
  :hook ((after-init . global-hl-line-mode)
         ((dashboard-mode eshell-mode shell-mode term-mode vterm-mode) .
          (lambda () (setq-local global-hl-line-mode nil)))))
#+end_src

*** Paren
#+begin_src emacs-lisp
;; Highlight matching parens
(use-package paren
  :straight (:type built-in)
  :hook (after-init . show-paren-mode)
  :init (setq show-paren-when-point-inside-paren t
              show-paren-when-point-in-periphery t)
  :config
  (with-no-warnings
    ;; Display matching line for off-screen paren.
    (defun display-line-overlay (pos str &optional face)
      "Display line at POS as STR with FACE.
FACE defaults to inheriting from default and highlight."
      (let ((ol (save-excursion
                  (goto-char pos)
                  (make-overlay (line-beginning-position)
                                (line-end-position)))))
        (overlay-put ol 'display str)
        (overlay-put ol 'face
                     (or face '(:inherit highlight)))
        ol))

    (defvar-local show-paren--off-screen-overlay nil)
    (defun show-paren-off-screen (&rest _args)
      "Display matching line for off-screen paren."
      (when (overlayp show-paren--off-screen-overlay)
        (delete-overlay show-paren--off-screen-overlay))
      ;; Check if it's appropriate to show match info,
      (when (and (overlay-buffer show-paren--overlay)
                 (not (or cursor-in-echo-area
                          executing-kbd-macro
                          noninteractive
                          (minibufferp)
                          this-command))
                 (and (not (bobp))
                      (memq (char-syntax (char-before)) '(?\) ?\$)))
                 (= 1 (logand 1 (- (point)
                                   (save-excursion
                                     (forward-char -1)
                                     (skip-syntax-backward "/\\")
                                     (point))))))
        ;; Rebind `minibuffer-message' called by `blink-matching-open'
        ;; to handle the overlay display.
        (cl-letf (((symbol-function #'minibuffer-message)
                   (lambda (msg &rest args)
                     (let ((msg (apply #'format-message msg args)))
                       (setq show-paren--off-screen-overlay
                             (display-line-overlay
                              (window-start) msg ))))))
          (blink-matching-open))))
    (advice-add #'show-paren-function :after #'show-paren-off-screen)))
#+end_src

*** Highlight TODO
#+begin_src emacs-lisp
;; Highlight TODO and similar keywords in comments and strings
(use-package hl-todo
  :custom-face
  (hl-todo ((t (:inherit default :height 0.9 :width condensed :weight bold :underline nil :inverse-video t))))
  :bind (:map hl-todo-mode-map
              ([C-f3] . hl-todo-occur)
              ("C-c t p" . hl-todo-previous)
              ("C-c t n" . hl-todo-next)
              ("C-c t o" . hl-todo-occur)
              ("C-c t i" . hl-todo-insert))
  :hook (after-init . global-hl-todo-mode)
  ;; :init (setq hl-todo-require-punctuation t
	      ;; hl-todo-highlight-punctuation ":")
  :config
  (dolist (keyword '("BUG" "DEFECT" "ISSUE"))
    (cl-pushnew `(,keyword . ,(face-foreground 'error)) hl-todo-keyword-faces))
  (dolist (keyword '("WORKAROUND" "HACK" "TRICK"))
    (cl-pushnew `(,keyword . ,(face-foreground 'warning)) hl-todo-keyword-faces)))
#+end_src

*** Highlight uncommitted changes
#+begin_src emacs-lisp
;; Highlight uncommitted changes using VC
(use-package diff-hl
  :bind (:map diff-hl-command-map
         ("SPC" . diff-hl-mark-hunk))
  :hook ((after-init . global-diff-hl-mode)
         (dired-mode . diff-hl-dired-mode)
         ((after-load-theme server-after-make-frame) . my-set-diff-hl-faces))
  :init (setq diff-hl-draw-borders nil
	      diff-hl-side 'right)
  :config
  ;; Highlight on-the-fly
  (diff-hl-flydiff-mode 1)

  ;; Set fringe style
  (setq-default fringes-outside-margins t)

  (defun my-set-diff-hl-faces ()
    "Set `diff-hl' faces."
    (custom-set-faces
     `(diff-hl-change ((t (:foreground ,(face-background 'highlight) :background nil))))
     '(diff-hl-insert ((t (:inherit diff-added :background nil))))
     '(diff-hl-delete ((t (:inherit diff-removed :background nil))))))

  (with-no-warnings
    (defun my-diff-hl-fringe-bmp-function (_type _pos)
      "Fringe bitmap function for use as `diff-hl-fringe-bmp-function'."
      (define-fringe-bitmap 'my-diff-hl-bmp
        (vector #b11100000)
        1 8
        '(center t)))
    (setq diff-hl-fringe-bmp-function #'my-diff-hl-fringe-bmp-function)

    (unless (display-graphic-p)
      ;; Fall back to the display margin since the fringe is unavailable in tty
      (diff-hl-margin-mode 1)
      ;; Avoid restoring `diff-hl-margin-mode'
      (with-eval-after-load 'desktop
        (add-to-list 'desktop-minor-mode-table
                     '(diff-hl-margin-mode nil))))

    ;; Integration with magit
    (with-eval-after-load 'magit
      (add-hook 'magit-pre-refresh-hook #'diff-hl-magit-pre-refresh)
      (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh))))
#+end_src

*** visual-fill-column
#+begin_src emacs-lisp
(use-package visual-fill-column
  :hook
  (org-mode . visual-fill-column-mode)
  (markdown-mode . visual-fill-column-mode)
  :init
  (setq-default visual-fill-column-center-text t
		visual-fill-column-width 100))
#+end_src

*** Writeroom-mode
#+begin_src emacs-lisp
(use-package writeroom-mode
  :commands (writeroom-mode)
  :hook
  (writeroom-mode-enable . (lambda () (tab-bar-mode 0)))
  (writeroom-mode-disable . (lambda () (tab-bar-mode 1)))
  (kill-buffer . (lambda () (tab-bar-mode 1)))
  :config
  (setq writeroom-fullscreen-effect 'maximized))
#+end_src

* Window
** Popper
#+begin_src emacs-lisp
(use-package popper
  :bind (("C-`"   . popper-toggle-latest)
         ("M-`"   . popper-cycle)
         ("C-M-`" . popper-toggle-type))
  :hook
  (after-init . popper-mode)
  (popper-mode . popper-echo-mode)
  :init
  (setq popper-reference-buffers
        '("[Oo]utput\\*$"
          "^\\*Warnings\\*"
          "^\\*Compile-Log\\*"
          "^\\*Messages\\*"
          "^\\*Backtrace\\*"
          "^\\*ielm\\*"
          "^\\*Tex Help\\*"
          "^\\*Shell Command Output\\*"
          "^\\*Async Shell Command\\*"
          "^\\*WordNut\\*"
          "^\\*help[R].*"
          "^\\*polymode export\\*"
          help-mode
          eshell-mode
	  vterm-mode
          message-mode
          compilation-mode)))
#+end_src

** Window history with winner-mode
#+begin_src emacs-lisp
(use-package winner
  :hook (after-init . winner-mode)
  :bind
  ("s-u" . winner-undo)
  ("s-U" . winner-redo))
#+end_src

** Window split preference
#+begin_src emacs-lisp
;; set preference to horizontal split
(defun split-window-sensibly-prefer-horizontal (&optional window)
  "Based on split-window-sensibly, but designed to prefer a horizontal split,
i.e. windows tiled side-by-side."
  (interactive)
  (let ((window (or window (selected-window))))
    (or (and (window-splittable-p window t)
             ;; Split window horizontally
             (with-selected-window window
               (split-window-right)))
        (and (window-splittable-p window)
             ;; Split window vertically
             (with-selected-window window
               (split-window-below)))
        (and
         (let ((frame (window-frame window)))
           (or
            (eq window (frame-root-window frame))
            (catch 'done
              (walk-window-tree (lambda (w)
                                  (unless (or (eq w window)
                                              (window-dedicated-p w))
                                    (throw 'done nil)))
                                frame)
              t)))
         (not (window-minibuffer-p window))
         (let ((split-width-threshold 0))
           (when (window-splittable-p window t)
             (with-selected-window window
               (split-window-right))))))))

(setq split-width-threshold  80
      split-height-threshold 80
      xsplit-window-preferred-function 'split-window-sensibly-prefer-horizontal)
#+end_src

** Control Buffer Placement
I combine this with =popper.el= now! This is a great feature, as popper turn these buffers to =pop= buffer, so that I could toggle with ~C-`~. Besides =pop= buffer would change my current window placement.
#+begin_src emacs-lisp
;; hook to popper-mode in case popper overwrite this behavior
(add-hook 'popper-mode-hook (lambda ()
  (setq display-buffer-base-action
	'(display-buffer-reuse-mode-window
          display-buffer-reuse-window
          display-buffer-same-window))

  ;; If a popup does happen, don't resize windows to be equal-sized
  (setq even-window-sizes nil)

  (setq display-buffer-alist
	'(;; top side window
          ("\\*\\(Flymake\\|Package-Lint\\|vc-git :\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.1)
           (side . top)
           (slot . 0))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.1)
           (side . top)
           (slot . 1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.1)
           (side . top)
           (slot . 2))
          ("\\*polymode export.*"
           (display-buffer-in-side-window)
           (window-height . 0.1)
           (side . top)
           (slot . 1))
          ;; right side window
          ("\\*[Hh]elp.*"            ; See the hooks for `visual-line-mode'
           (display-buffer-in-side-window)
           (window-width . 0.5)
           (side . right)
           (slot . -1))
	  ("\\*Man.*"
           (display-buffer-in-side-window)
           (window-width . 0.5)
           (side . right)
           (slot . -1))
          ("\\*eglot doc.*"
           (display-buffer-in-side-window)
           (window-width . 0.5)
           (side . right)
           (slot . -1))
          ("\\*\\(R\\|Python\\).*"
           (display-buffer-reuse-mode-window)
           (side . right)
           (slot . -1)
           (window-width . 0.3))
          ;; left side window
	  ("^\\*Ilist\\*$"
	   (display-buffer-in-side-window)
	   (window-width . 0.2)
	   (side . left)
	   (slot . -1))
          ;; bottom buffer (NOT side window)
          ("\\*.*\\(e?shell\\|v?term\\).*"
           (display-buffer-at-bottom)
           ;; (display-buffer-in-side-window)
           (window-height . 0.2)
           (side . bottom))
          ;; ("\\*R.*"
          ;;  (display-buffer-reuse-mode-window display-buffer-at-bottom)
          ;;  (window-height . 0.3))
          ;; below current window
          ("\\*Calendar.*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . shrink-window-if-larger-than-buffer))))

  ;; If a popup does happen, don't resize windows to be equal-sized
  (setq even-window-sizes nil)))
#+end_src

* Editing
** Undo tree

   #+begin_src emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :hook (after-init . global-undo-tree-mode)
  :bind
  ("s-z" . undo-tree-undo)
  ("s-Z" . undo-tree-redo)
  :init
  (setq undo-tree-visualizer-diff t
	undo-tree-visualizer-timestamps t
        undo-tree-enable-undo-in-region nil
        undo-tree-auto-save-history nil))
   #+end_src
   
** Auto save
Auto-Saving Changed Files

 #+begin_src emacs-lisp
(use-package super-save
  :diminish
  :hook (after-init . super-save-mode)
  :init
  (setq super-save-auto-save-when-idle t))
 #+end_src

** Sudo edit
   #+begin_src emacs-lisp
(use-package sudo-edit
  :defer 1
  :commands (sudo-edit))
   #+end_src

** Snippets
#+begin_src emacs-lisp
(use-package yasnippet
  :hook (after-init . yas-global-mode)
  :init (setq yas-snippet-dirs '("~/.emacs.d/yasnippet")))
#+end_src

** Visual regexp
#+begin_src emacs-lisp
(use-package visual-regexp
  :defer 2)
#+end_src

** Color editing
#+begin_src emacs-lisp
(use-package ct
  :defer 3)
#+end_src

* Completion
** Orderless
#+begin_src emacs-lisp
;; orderless
(use-package orderless
  :config
  (setq completion-styles '(orderless partial-completion basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Minibuffer Completion
*** vertigo
#+begin_src emacs-lisp
(use-package vertico
  :straight (:files (:defaults "extensions/*")
		    :includes (vertico-buffer
			       vertico-directory
			       vertico-flat
			       vertico-indexed
			       vertico-mouse
			       vertico-quick
			       vertico-repeat
			       vertico-reverse))
  :hook
  (after-init . vertico-mode)
  ;; Tidy shadowed file names
  (rfn-eshadow-update-overlay . vertico-directory-tidy)
  ;; More convenient directory navigation commands
  :bind (:map vertico-map
              ("RET" . vertico-directory-enter)
              ("DEL" . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
  :init
  (setq vertico-resize nil
	vertico-scroll-margin 0
	vertico-count 12
	vertico-cycle t)
  :config
  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src

*** marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
         ("M-A" . marginalia-cycle))
  :hook (vertico-mode . marginalia-mode))

(use-package all-the-icons-completion
  :after (marginalia all-the-icons)
  :hook
  (marginalia-mode . all-the-icons-completion-marginalia-setup)
  (marginalia-mode . all-the-icons-completion-mode)
  :init
  (setq marginalia-max-relative-age 0
	marginalia-align 'center))
#+end_src

*** consult
#+begin_src emacs-lisp
(use-package consult
  :bind (;; C-c bindings (mode-specific-map)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-c k" . consult-kmacro)
         ;; C-x bindings (ctl-x-map)
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
	 ("C-x C-b" . consult-buffer)
	 ("C-x C-d" . consult-dir)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ("<help> a" . consult-apropos)            ;; orig. apropos-command
	 ("s-f" . consult-line)                ;; orig. yank-pop
         ;; M-g bindings (goto-map)
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g i" . consult-imenu)
         ;; M-s bindings (search-map)
         ("M-s d" . consult-find)
         ("M-s g" . consult-grep)
	 ("M-s b" . consult-bibtex-open-pdf)
	 ("M-s y" . consult-yasnippet)
	 ("M-s c" . consult-flycheck)
	 ("M-s m" . consult-minor-mode-menu)
	 :map isearch-mode-map
         ("M-s" . consult-isearch-history)
	 :map minibuffer-local-completion-map
         ("C-x C-d" . consult-dir))
  :init
  (setq consult-preview-key nil)
  :config
  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-recent-file
   consult--source-project-recent-file :preview-key (kbd "M-."))

  ;; Optionally configure the narrowing key.
  (setq consult-narrow-key "<" ;; (kbd "C-+")
	consult-line-numbers-widen t
        consult-async-min-input 2
        consult-async-refresh-delay  0.15
        consult-async-input-throttle 0.2
        consult-async-input-debounce 0.1)

  ;; use projectile in consult
  (autoload 'projectile-project-root "projectile")
  (setq consult-project-function (lambda (_) (projectile-project-root)))

  ;; Preview while using consult-theme
  (consult-customize consult-theme :preview-key '(:debounce 0.5 any))
  ;; Preview immediately on M-., on up/down after 0.5s, on any other key after 1s
  (consult-customize consult-theme
                     :preview-key
                     (list (kbd "M-.")
                           :debounce 0.5 (kbd "<up>") (kbd "<down>")
                           :debounce 1 'any))

  ;; custom consult packages
  (use-package consult-yasnippet :after consult :commands (consult-yasnippet))
  (use-package consult-bibtex :after consult
    :straight `(consult-bibtex :host github :repo "mohkale/consult-bibtex"))
  (use-package consult-dir :after consult)
  (use-package consult-flycheck
		:after (consult flycheck)))

;; use this for now untill consult have its web-search
(use-package google-this :bind ("C-c l" . google-this-search))
#+end_src

*** embark
#+begin_src emacs-lisp
(use-package embark
  :bind
  (("M-," . embark-act)         ;; pick some comfortable binding
   ("M-." . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)
  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
#+end_src

** Code Completion
*** dabbrev
#+begin_src emacs-lisp
(use-package dabbrev
  :custom
  ;; since cape-dabbrev cannot replace case, I will set it to nil for now.
  (dabbrev-case-fold-search nil)
  (dabbrev-case-replace t))
#+end_src

*** corfu
#+begin_src emacs-lisp
(use-package corfu
  :hook
  (after-init . global-corfu-mode)
  :bind
  (:map corfu-map
	("TAB" . corfu-insert)
        ([tab] . corfu-insert)
        ([escape] . corfu-quit)
        ([return] . corfu-insert)
        ("M-d" . corfu-show-documentation)
        ("M-l" . corfu-show-location)
	("SPC" . corfu-insert-separator))
  :init
  ;; fast prefix filtering
  (defun orderless-fast-dispatch (word index total)
    (and (= index 0) (= total 1) (length< word 4)
       `(orderless-regexp . ,(concat "^" (regexp-quote word)))))

  (orderless-define-completion-style orderless-fast
    (orderless-dispatch '(orderless-fast-dispatch))
    (orderless-matching-styles '(orderless-literal orderless-regexp)))

  (setq corfu-cycle t
	corfu-auto t
	corfu-auto-delay 0
	corfu-auto-prefix 1
	completion-styles '(orderless-fast)
	corfu-preselect-first t
	corfu-quit-no-match t
	corfu-on-exact-match 'insert
	corfu-preview-current nil
	corfu-echo-documentation nil
	corfu-scroll-margin 5
	corfu-count 10
	corfu-min-width 20
	corfu-max-width 80)
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)
  ;; disable corfu auto in following modes
  (dolist (hook '(inferior-ess-r-mode-hook))
    (add-hook hook (lambda () (setq-local corfu-auto nil))))
  ;; setup corfu in lsp mode
  (with-eval-after-load 'lsp-mode
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless))
    (setq lsp-completion-provider :none))
  :config
  ;; set icon for corfu
  (require 'kind-all-the-icons)
  (add-to-list 'corfu-margin-formatters
               #'kind-all-the-icons-margin-formatter))
#+end_src

*** corfu doc
#+begin_src emacs-lisp
(use-package corfu-doc
  :hook
  (corfu-mode . corfu-doc-mode)
  :bind
  (:map corfu-map
        ("M-p" . corfu-doc-scroll-down)
        ("M-n" . corfu-doc-scroll-up)
	("M-d" . corfu-doc-toggle))
  :config
  (setq corfu-doc-auto nil))
#+end_src

*** cape
#+begin_src emacs-lisp
(use-package cape
  :after corfu
  :bind
  ("C-c f" . cape-file)
  ("C-c d" . cape-dabbrev)
  :hook
  (after-change-major-mode . add-cape-completion)
  :init
  (defun add-cape-completion ()
    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-dabbrev t)))
#+end_src

* Development
#+begin_src emacs-lisp
(org-babel-load-file "~/.emacs.d/emacs-development.org")
#+end_src

* Academic
  #+begin_src emacs-lisp
(org-babel-load-file "~/.emacs.d/emacs-academic.org")
  #+end_src

* System
** Desktop-EXWM
This part is largely copied from daviwil's course.

#+begin_src emacs-lisp :tangle "no"
(when (eq system-type 'gnu/linux)
  (org-babel-load-file "~/.emacs.d/emacs-desktop.org"))
#+end_src

** Archlinux

#+begin_src emacs-lisp :tangle "no"
(when (eq system-type 'gnu/linux)
  (org-babel-load-file "~/.emacs.d/emacs-system.org"))
#+end_src

** WSL

To install emacs on wsl: https://emacsredux.com/blog/2021/12/19/using-emacs-on-windows-11-with-wsl2/
   
In old windows 10, you may not able to start emacs-gtk. Solution is:  https://github.com/microsoft/WSL/issues/4106#issuecomment-876470388
   
#+begin_src emacs-lisp :tangle "no"
(when (getenv "WSL_DISTRO_NAME")
  (progn
    (cua-mode 1)
    (global-set-key (kbd "C-{") 'windmove-left)          ; move to left window
    (global-set-key (kbd "C-|") 'windmove-right)        ; move to right window
    (global-set-key (kbd "C-}") 'windmove-up)              ; move to upper window
    (global-set-key (kbd "C-\"") 'windmove-down)          ; move to lower window
    (global-set-key (kbd "M-#") 'winner-undo)
    (global-set-key (kbd "M-*") 'counsel-projectile-switch-project)
    (global-set-key (kbd "C-(") 'delete-window)
    (global-set-key (kbd "C-t") 'split-window-sensibly-prefer-horizontal)
    (global-set-key (kbd "C-!") 'kill-current-buffer)))
#+end_src
